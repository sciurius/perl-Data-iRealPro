#! perl

package Music::iRealBook::Opus;

use strict;
use warnings;
use 5.010;
use utf8;
use parent qw( Music::ChordBot::Opus );
use Music::iRealBook;

=head2 composer I<title>

Sets the composer name for the song.

=cut

sub composer { shift->_setget( "composer", @_ ) }
sub key { shift->_setget( "key", @_ ) }
sub style { shift->_setget( "style" ) }

sub set_style {
    my ( $self, $style ) = @_;
    $self->{style} = $style;
}

my %_namemap = (
		Verse	 => '*v',
		Intro	 => '*i',
		Coda	 => 'Q',
		Segno	 => 'S',
		Fermata	 => 'f',
		A	 => '*A',
		B	 => '*B',
		C	 => '*C',
		D	 => '*D',
);

sub irealbook {
    my ( $self, %args ) = @_;

    my $type = delete( $args{type} ) // "html";

    my $ir = '';

    my $maybecomma = sub {
	$ir .= "," if $ir =~ /[[:alpha:]]$/i;
    };

    foreach my $section ( @{ $self->data->{sections} } )  {
	my $beatspermeasure = $section->{style}->{beats} // 4;
	my $beatstype = $section->{style}->{divider} // 4;
	$ir .= "[" . timesig( $beatspermeasure, $beatstype );
	if ( $section->{name} ) {
	    $ir .= ( $_namemap{ $section->{name} }
	      //  "<*72" . $section->{name} . ">" );
	}

	my $beats = 0;
	foreach my $el ( @{ $section->{chords} } ) {
	    if ( $el->{is_a} eq "chord" ) {
		my $chord = $el;
		my $did = 0;
		for ( 1..$chord->{duration} ) {
		    if ( $beats == $beatspermeasure ) {
			$beats = 0;
			$ir .= "|";
			$did = 0;
		    }
		    if ( $did ) {
			$ir .= " ";
		    }
		    else {
			$maybecomma->();
			$ir .= $chord->{root};
			$ir .= _type( $chord->{type} );
			if ( $chord->{bass} ) {
			    $ir .= "/" . $chord->{bass};
			}
			$did++;
		    }
		    $beats++;
		}
		next;
	    }
	    if ( $el->{is_a} eq "timesig" ) {
		$beatspermeasure = $el->{beatspermeasure};
		$beatstype       = $el->{beatstype};
		$maybecomma->();
		$ir .= "|" . timesig( $beatspermeasure, $beatstype );
		$beats = 0;
		next;
	    }
	}
	$ir .= "]";
    }

    $ir =~ s/\]$/Z/;		# End bar

    $ir = join( "=",
		$self->name,
		$self->composer // "Composer",
		$self->style // "Rock Ballad",
		"n",
		$self->key // "C",
		$ir,
		"",		# actual style
		$self->tempo,
		"" );

    $ir =~ s/([^A-Za-z0-9\-_.!~*'()])/sprintf("%%%02x", ord($1))/ge
      unless $type eq "plain";
    $ir = "irealbook://" . $ir;

    if ( $type eq "html" ) {
	my $title = $self->name;
	$title =~ s/&/&amp;/g;
	$title =~ s/>/&gt;/g;
	$title =~ s/</&lt;/g;
	$ir = <<EOD;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>$title</title>
</head>

<body>
<h1>$title</h1>

<p><a href="$ir">$title</a></p>

<p><font size="-1">Generated by Music::iRealBook version $Music::iRealBook::VERSION.</font></p>

</body> </html>
EOD
    }

    return $ir;
}

sub timesig {
    my ( $beatspermeasure, $beatstype ) = @_;
    my $r = "T" . $beatspermeasure . $beatstype;
    $r =~ s/T128$/T12/;	# 12/8 -> T12
    return $r;
}

# Obfuscate/deobfuscate irealb pro format.
sub irealb_obfuscate {
    my ( $string ) = @_;
    my $result = '';

    while ( length($string) > 50 ) {

	# Treat 50-byte segments.
	my $segment = substr( $string, 0, 50, '' );
	if ( length($string) < 2 ) {
	    $result .= $segment;
	    next;
	}

	# Obfuscate a 50-byte segment.
	$result .= reverse( substr( $segment, 45,  5 ) ) .
		   substr( $segment,  5, 5 ) .
		   reverse( substr( $segment, 26, 14 ) ) .
		   substr( $segment, 24, 2 ) .
		   reverse( substr( $segment, 10, 14 ) ) .
		   substr( $segment, 40, 5 ) .
		   reverse( substr( $segment,  0,  5 ) );
    }

    return $result . $string;
}

sub irealb {
    my ( $self, %args ) = @_;

    my $type = delete( $args{type} ) // "html";

    my $ir = "";

    foreach my $section ( @{ $self->data->{sections} } )  {
	my $beatspermeasure = $section->{style}->{beats} // 4;
	my $beatstype = $section->{style}->{divider} // 4;
	$ir .= "[" . timesig( $beatspermeasure, $beatstype );
	if ( $section->{name} ) {
	    $ir .= "<*72" . $section->{name} . ">";
	}

	my $beats = 0;
	foreach my $chord ( @{ $section->{chords} } ) {
	    my $did = 0;
	    for ( 1..$chord->{duration} ) {
		if ( $beats == $beatspermeasure ) {
		    $beats = 0;
		    $ir =~ s/  +$/XyQ|/;
		    $ir =~ s/ $/LZ|/;
		    $did = 0;
		}
		if ( $did ) {
		    $ir .= " ";
		}
		else {
		    $ir .= $chord->{root};
		    $ir .= _type( $chord->{type} );
#		    $ir .= ",";		# for safety
		    $did++;
		}
		$beats++;
	    }
	}

	$ir .= "]";
    }

    $ir =~ s/\]$/Z/;		# End bar

    $ir = join( "=",
		$self->name,
		$self->composer // "Composer",
		"",
		$self->style // "Rock Ballad",
		$self->key // "C",
		"",
		"1r34LbKcu7" . irealb_obfuscate($ir),
		"",
		"0",
		"0",
	      );

    $ir =~ s/([^A-Za-z0-9\-_.!~*'()])/sprintf("%%%02x", ord($1))/ge
      unless $type eq "plain";
    $ir = "irealb://" . $ir;

    if ( $type ne "text" ) {
	my $title = $self->name;
	$title =~ s/&/&amp;/g;
	$title =~ s/>/&gt;/g;
	$title =~ s/</&lt;/g;
	$ir = <<EOD;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>$title</title>
</head>

<body>
<h1>$title</h1>

<p><a href="$ir">$title</a></p>

<p><font size="-1">Generated by Music::iRealBook version $Music::iRealBook::VERSION.</font></p>

</body> </html>
EOD
    }

    return $ir;
}

my %types = ( "Maj"	  => "",
	      "Min"	  => "-",
	      "7"	  => "7",
	      "Min7"	  => "-7",
	      "Maj7"	  => "^7",
	      ""	  => "7sus",
	      ""	  => "ø7",
	      "Dim7"	  => "o7",
	      ""	  => "5",
	      ""	  => "2",
	      ""	  => "add9",
	      "Aug"	  => "+",
	      "Dim"	  => "o",
#	      "Min7(b5)"  => "o7",
	      "Min7(b5)"  => "h7",
	      ""	  => "ø",
	      "Sus"	  => "sus",
	      ""	  => "^",
	      ""	  => "-",
	      ""	  => "^9",
	      ""	  => "^13",
	      "6"	  => "6",
	      "69"	  => "69",
	      ""	  => "^7#11",
	      ""	  => "^9#11",
	      ""	  => "^7#5",
	      "Min6"	  => "-6",
	      "Min69"	  => "-69",
	      ""	  => "-b6",
	      ""	  => "-^7",
	      ""	  => "-^9",
	      "Min9"	  => "-9",
	      "Min11"	  => "-11",
	      ""	  => "ø9",
	      ""	  => "-7b5",
	      "9"	  => "9",
	      ""	  => "7b9",
	      ""	  => "7#9",
	      ""	  => "7#11",
	      ""	  => "9#11",
	      ""	  => "9#5",
	      ""	  => "9b5",
	      "7(b5)"	  => "7b5",
	      ""	  => "7#5",
	      ""	  => "7b13",
	      ""	  => "7#9#5",
	      ""	  => "7#9b5",
	      ""	  => "7#9#11",
	      ""	  => "7b9#11",
	      ""	  => "7b9b5",
	      ""	  => "7b9#5",
	      ""	  => "7b9#9",
	      ""	  => "7b9b13",
	      ""	  => "7alt",
	      "13"	  => "13",
	      ""	  => "13#11",
	      ""	  => "13#9",
	      ""	  => "13b9",
	      ""	  => "7b9sus",
	      ""	  => "7susadd3",
	      ""	  => "9sus",
	      ""	  => "13sus",
	      ""	  => "7b13sus",
	      "11"	  => "11",

	    );

sub _type {
    $types{ shift() } // "";
}

1;
