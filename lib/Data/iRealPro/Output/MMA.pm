#! perl

# Data::iRealPro::Output::MMA -- produce MMA song

# Author          : Johan Vromans
# Created On      : Mon Jan  7 08:20:16 2019
# Last Modified By: Johan Vromans
# Last Modified On: Wed Jan  9 08:26:06 2019
# Update Count    : 298
# Status          : Unknown, Use with caution!

################ Common stuff ################

use strict;
use warnings;
use Carp;
use utf8;

package Data::iRealPro::Output::MMA;

my $VERSION = "0.01";

use parent qw( Data::iRealPro::Output::Base );

use Data::iRealPro::URI;
use Data::Dumper;

my $regtest = $ENV{IRP_REGTEST};

my %stype = ( i => "Intro",
	      v => "Verse",
	      coda => "Coda",
	    );

sub options {
    my $self = shift;
    [ @{ $self->SUPER::options }, qw( split dir ) ];
}

sub process {
    my ( $self, $u, $options ) = @_;

    for ( qw( trace debug verbose ) ) {
	$self->{$_} = $options->{$_} if exists $options->{$_};
    }

    unless ( $self->{split} ) {

	$self->{output} ||= $options->{output} || "__new__.mma";

	if ( $u->{transpose} ) {
	    foreach my $song ( @{ $u->{playlist}->{songs} } ) {
		# Do not change key to actual.
		local $song->{_transpose} = 0;

		$song->{key} = $song->xpose($song->{key} // "C");
		if ( $song->{actual_key} ne '' ) {
		    $song->{actual_key} =
		      ( $song->{actual_key} + $song->{transpose} ) % 12;
		}
		$song->tokenize;
		$song->{data} = $song->{dataxp} if $song->{dataxp};
	    }
	}

	if ( ref( $self->{output} ) ) {
	    ${ $self->{output} } = $self->to_mma($u);
	}
	else {
	    open( my $fd, ">:utf8", $self->{output} )
	      or croak( "Cannot create ", $self->{output}, " [$!]\n" );
	    print $fd $self->to_mma($u);
	    close($fd);
	}
	return;
    }

    my $outdir = $self->{dir} || "";
    $outdir .= "/" if $outdir && $outdir !~ m;/$;;
    make_path( $outdir, {} ) unless -d $outdir;

    foreach my $song ( @{ $u->{playlist}->{songs} } ) {
	# Do not change key to actual.
	local $song->{_transpose} = 0;

	if ( $song->{transpose} ) {
	    $song->{key} = $song->xpose($song->{key} // "C");
	    if ( $song->{actual_key} ne '' ) {
		$song->{actual_key} =
		  ( $song->{actual_key} + $song->{transpose} ) % 12;
	    }
	    $song->tokenize;
	    $song->{data} = $song->{dataxp} if $song->{dataxp};
	}

	# Make a playlist with just this song.
	my $pls = Data::iRealPro::Playlist->new( song => $song );

	# Make an URI for this playlist.
	my $uri = Data::iRealPro::URI->new( playlist => $pls );

	# Write it out.
	my $title = $song->{title};
	# Mask dangerous characters.
	$title =~ s/[:?\\\/*"<>|]/@/g;
	my $file = $outdir.$title.".html";
	my $out = encode_utf8($file);
	open( my $fd, '>:utf8', $out )
	  or die( "$out: $!\n" );
	print $fd to_mma($uri);
	close($fd);
	warn( "Wrote $out\n" )
	  if $self->{verbose};
    }
}

sub to_mma {
    my ( $self, $u ) = @_;

    my $pl = $u->{playlist};
    my $title;
    if ( $pl->{name} ) {
	$title = $pl->{name};
    }
    else {
	$title = $pl->{songs}->[0]->{title};
    }
    my $vv = $regtest ? "" : " version $Data::iRealPro::VERSION";

    my $song = $u->{playlist}->{songs}->[0];
    my $tempo = $song->{actual_tempo} || 120;

    my $time_d;
    my $time_n;
    my $time = "4/4";
    foreach ( @{ $song->tokens } ) {
	next unless /time (\d\/\d)/;
	$time = $1;
	last;
    }
    ( $time_d, $time_n ) = $time =~ m;^(\d+)/(\d+)$;;

    my @t = split( ' ', $song->{composer} );
    @t[0,1] = @t[1,0] if @t == 2;
    my $mma = <<EOD;
// Title: @{[ $song->{title} ]}
// Style: @{[ $song->{style} ]}
// Composer: @t
// Converted from iReal by Data::iRealPro $Data::iRealPro::VERSION

MIDIText @{[ $song->{title} ]}
MIDIText MMA input generated by @{[__PACKAGE__]} version $Data::iRealPro::VERSION

KeySig @{[ key2mma($song->{key}) ]}
Time $time_d
TimeSig $time
Tempo $tempo

EOD

    my $s = $self->interpret($song);
    my $mcnt = 0;
    my $in_intro = 1;
    my $grepeat = $song->{actual_repeats} || 3;
    my $repeat;
    my $ending;

    my $has_jumps;
    foreach ( @{ $s->{content} } ) {
	next unless $_->{hasjumps};
	$has_jumps++;
	last;
    }

    if ( $grepeat > 1 ) {
	$mma .= "Set SongForms $grepeat\n"; # if $has_jumps;
    }
    $mma .= "\nLabel Capo\n" if $has_jumps;

    foreach my $section ( @{ $s->{content} } ) {
	# print "section ", $section->{type}, "\n";
	next unless @{ $section->{content} };
	my $type = $section->{type};
	next if $type eq "hspace";

	if ( $in_intro && $type ne 'i' ) {
	    if ( $grepeat > 1 ) {
		$mma .= "\nRepeat         // song form\n";
	    }
	    $in_intro = 0;
	}

	# iRealPro has two styles of song form repeats. Normally,
	# the coda part comes after the song form. However, when
	# jumps are used, the coda part becomes part of the song form.
	elsif ( $type eq "coda" && !$has_jumps ) {
	    if ( $grepeat > 1 ) {
		$mma .= "\n" . endrepeat( 1||$has_jumps ? '$SongForms' : $grepeat, "song form" );
		$grepeat = 0;
	    }
	}

	$mma .= "\n// Section: " . ($stype{$type}//$type) . "\n";
	$mma .= "Label Coda\n" if $has_jumps && $type eq "coda";
	$mma .= "Groove " . style2mma( $song->{style} ) . "\n";
	foreach my $item ( @{ $section->{content} } ) {
	    # print "item ", $item->{type}, "\n";

	    if ( $item->{type} eq "measure" ) {
		$mcnt++;
		my $res = sprintf("%3d", $mcnt);
		my @chords;
		foreach my $i ( @{ $item->{content} } ) {
		    # printf( "%3d  %s\n", $mcnt, "@$i" );
		    foreach my $j ( @$i ) {
			if ( $j =~ /^alternative (\d+)/ ) {
			    if ( $1 > $ending ) {
				my $n = 1 + $1 - $ending;
				$mma =~ s/^(.*RepeatEnding)( \d+)?(\n.*)/$1 $n$3/s;
				$ending = $n;
			    }
			    $mma .= "RepeatEnding\n";
			    $ending++;
			    next;
			}
			if ( $j =~ /^chord\s+(\S+)/ ) {
			    push( @chords, chord2mma($1) );
			}
			elsif ( $j =~ /^advance / ) {
			    next;
			}
			elsif ( $j =~ /^time\s+(\S+)/ ) {
			    warn("Time signature change: $time -> $1\n")
			      unless $1 eq $time;
			}
			elsif ( $j eq "segno" ) {
			    $mma .= "Label Segno\n";
			    next;
			}
			else {
			    $res .= " /* $j? */";
			}
		    }
		}
		if ( @chords < $time_d ) {
		    if ( @chords == 1 ) {
			# Okay, MMA will fill.
		    }
		    elsif ( @chords == 2 ) {
			splice( @chords, 1, 0, ("/") x int($time_d/2) );
		    }
		}
		$res .= " @chords";
		$res .= "   /* " . $item->{jump}->{text} ." */" if $item->{jump};
		$mma .= $res . "\n";
	    }
	    elsif ( $item->{type} eq "start repeat" ) {
		$repeat = 2;
		$mma .= "Repeat\n";
		$ending = 1;
	    }
	    elsif ( $item->{type} eq "end repeat" ) {
		$mma .= endrepeat($item->{repeat} || $repeat);
		$repeat = 0;
	    }
	    else {
		warn("OOPS: ", $item->{type}, "\n");
	    }
	}
    }

    if ( $repeat ) {
	$mma .= "\n" . endrepeat($repeat);
    }
    if ( $grepeat > 1 ) {
	if ( 1||$has_jumps ) {
	    $mma .= "\n" . endrepeat('$SongForms');
	}
	else {
	    $mma .= "\n" . endrepeat($grepeat, "song form" );
	}
    }
    $mma;
}

sub endrepeat {
    my ( $n, $comment ) = @_;
    my $res = "RepeatEnd";
    if ( $n =~ /^\$/ ) {
	$res .= " NoWarn $n";
    }
    elsif ( $n ne "2" ) {
	$res .= " $n";
    }
    $res .= "    // $comment" if $comment;
    $res . "\n";
}

sub interpret {
    my ( $self, $song ) = @_;
    my $tokens = [ @{ $song->tokens } ];

    while ( $tokens->[0] =~ /^advance|hspace/ ) {
	shift(@$tokens);
    }
    while ( $tokens->[-1] =~ /^advance|hspace/ ) {
	pop(@$tokens);
    }
    my $res = { tokens => [ @$tokens ],
		content => [] };

    my $section;		# current section
    my $measure;		# current measure
    my $cell;			# current cell

    my $new_cell = sub {
	$cell = [];
    };

    my $new_measure = sub {
	$new_cell->();
	push( @{ $section->{content} }, { %{ $measure } } )
	  if $measure && @{ $measure->{content} };
	$measure = { type    => "measure",
		     content => [],
		   };
    };

    my $new_section = sub {
	$new_measure->();
	push( @{$res->{content}}, { %$section } )
	  if $section && @{ $section->{content} };
	$section = { type    => "section",
		     content => [],
		     tokens  => [ @_ > 0 ? @_ : () ],
		   };
    };

    $new_section->();

    my $i = 0;
    my $barskip = 0;
    my $repeatpending;

    while ( @$tokens ) {
	my $t = shift(@$tokens);
	$i++;

	my $done = 0;
	# warn( $t, $barskip ? "*\n" : "\n" );

	# Treat marked repeat as a section start.
	if ( $t eq "start repeat" && $tokens->[0] =~ /^mark/
	     && @{ $section->{content} } ) {
	    unshift( @$tokens, $t );
	    $t = "start section";
	    # Fall through...
	}

	if ( $t eq "start section" ) {
	    $new_section->();
	    $barskip = 0;
	    next;
	}

	if ( $t =~ /^mark\s+(\S+)/ ) { # i, A, B, ...
	    $section->{type} = $1;
	    next;
	}

	if ( $t =~ /^hspace\s+(\d+)$/ ) {
	    next;
	}

	if ( $t eq "end section" ) {
	    $new_section->();
	    $barskip = 0;
	    next;
	}

	push( @{ $section->{tokens} }, $t );

	if ( $t =~ /^coda/ ) {
	    if ( @{ $section->{content} } == 0 && @{ $measure->{content} } == 0 ) {
		$section->{type} = $t;
	    }
	    else {
		$measure->{jump} = { text => "Coda", al => "coda" };
		$section->{hasjumps} = 1;
	    }
	    next;
	}

	if ( $t =~ /^text\s+\d+\s+(\d+)x$/ ) {
	    $repeatpending = $1;
	    next;
	}

	if ( $barskip ) {
	    if ( $t =~ /^(?:bar|end.*|start.*)$/ ) {
		$barskip = 0;
	    }
	    else {
		next;
	    }
	}

	if ( $t eq "end" ) {
	    last;
	}

	if ( $t eq "bar" || $t eq "end repeat" ) {
	    $new_measure->();
	    push( @{ $section->{content} },
		  { type => "end repeat", repeat => $repeatpending } )
	      if $t eq "end repeat";
	    next;
	}
	if ( $t eq "start repeat" ) {
	    $new_measure->();
	    push( @{ $section->{content} }, { type => "start repeat" } );
	    $repeatpending = 2;
	    next;
	}

	if ( $t =~ /^(chord\s+(.*)|advance\s+\d+)$/ ) {
	    push( @$cell, $t );
	    push( @{ $measure->{content} }, [ @$cell ] );
	    $new_cell->();
	    next;
	}

	if ( $t eq "measure repeat single" ) {
	    $measure = $section->{content}->[-1];
	    $barskip = 1;
	    next;
	}

	if ( $t =~ /^measure repeat double$/ ) {
	    push( @{ $section->{content} }, $section->{content}->[-2] );
	    $measure = $section->{content}->[-2];
	    $barskip = 1;
	    next;
	}

	if ( $t =~ /^text \d+ (.*)/ ) {
	    if ( my $jump = isjump($1) ) {
		$section->{hasjumps} = 1;
		$measure->{jump} = $jump;
	    }
	    next;
	}

	push( @$cell, $t );
    }
    $new_section->();

    if ( $self->{debug} ) {
	$Data::Dumper::Deepcopy = 1;
	warn Dumper($res);
    }

    return $res;
}

sub chord2mma {
    my ( $chord ) = @_;

    my $bass;
    if ( $chord =~ m;^(.+)/(.+)$; ) {
	$bass = $2;
	$chord = $1;
    }

    unless ( $chord =~ /^([ABCDEFGW])([b\#]?)([-m^o]?)(.*)$/ ) {
	Carp::croak("Invalid chord key: $chord");
    }

    my ( $root, $shfl, $min, $mod ) = ( $1, $2, $3, $4 );

    if ( $shfl ) {
	$root .= $shfl;
    }

    $root .= $min eq "-" ? "m"
	     : $min eq "^" ? "maj"
	       : $min eq "o" ? "dim"
		 : "";

    while ( $mod =~ s/([2345679])//g ) {
	$root .= $1;
    }

    $root .= "/$bass" if $bass;
    return $root;
}

sub key2mma {
    my ( $key ) = @_;

    unless ( $key =~ /^([ABCDEFGW])([b#])?([-m])?$/ ) {
	Carp::croak("Invalid key: $key");
    }

    my ( $root, $shfl, $min ) = ( $1, $2, $3 );

    if ( $shfl ) {
	$root .= $shfl;
    }
    $root .= $min ? " minor" : " major";

    return $root;

}

sub style2mma {
    my ( $style, $section ) = @_;
    return "CountrySwing";
}

sub isjump {
    my ( $code ) = @_;

    return unless
    $code =~ m{ ^
		D\. ([CS]) \. \s+ al \s+
		  ( Coda | Fine | (?:1st|2nd|3rd) \s+ End )
		$
	      }xoi;

    my $al = lc($2);
    $al = $1 if $al =~ /^(\d)/;
    { text => $code, da => $1 eq "C" ? "capo" : "segno", al => $al }
}
1;
